#!/usr/bin/env bash
# Add read-only git permissions for a repo to current project's Claude settings
#
# Usage:
#   bless-repo           # Bless current repo (git cmd:*)
#   bless-repo /path     # Bless other repo (git -C /path cmd:*)

set -euo pipefail

settings=".claude/settings.local.json"

# Read-only git commands to bless
cmds=(branch cat-file check-ignore diff fetch log ls-files ls-tree reflog remote rev-list show status)

if [[ $# -eq 0 ]]; then
  # No args: bless current repo without -C prefix
  use_c_flag=false
  repo="$(pwd)"
  label="current repo"
else
  # With arg: bless specified repo with -C prefix
  use_c_flag=true
  repo="$(cd "$1" && pwd)"  # Resolve to absolute path
  label="$repo"
fi

# Create settings file if needed
if [[ ! -f "$settings" ]]; then
  mkdir -p .claude
  echo '{}' > "$settings"
fi

# Get existing permissions
existing=$(jq -r '.permissions.allow // [] | .[]' "$settings" 2>/dev/null || echo "")

# Build list of new permissions (skip existing)
new_perms=()
skipped=()
for cmd in "${cmds[@]}"; do
  if $use_c_flag; then
    perm="Bash(git -C $repo $cmd:*)"
  else
    perm="Bash(git $cmd:*)"
  fi
  if echo "$existing" | grep -qxF "$perm"; then
    skipped+=("$cmd")
  else
    new_perms+=("$perm")
  fi
done

if [[ ${#new_perms[@]} -eq 0 ]]; then
  echo "All ${#cmds[@]} git commands already permitted for $label"
  exit 0
fi

# Add new permissions using jq
jq --argjson new "$(printf '%s\n' "${new_perms[@]}" | jq -R . | jq -s .)" '
  .permissions.allow = ((.permissions.allow // []) + $new)
' "$settings" > "$settings.tmp" && mv "$settings.tmp" "$settings"

echo "Added ${#new_perms[@]} git permissions for $label"
if [[ ${#skipped[@]} -gt 0 ]]; then
  echo "Skipped ${#skipped[@]} (already present): ${skipped[*]}"
fi
echo "Restart Claude to apply: claude -c"
